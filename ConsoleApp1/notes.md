Алгоритм (на примере исходного кода задания):

```java
public class Main { 
   public static void method(boolean... conditions) { 
      int x;
      x=1;          // [1, ""] - not under any if statement
      if (conditions[0]) {
        x=2; // [2, "1"]  -  located in one if-block
        if (conditions[1]) {
            x=3; // [3, "12"] - located in two opened if-blocks
        }
        x=4; // [4, "1"] - on the same level with 'x=2'
        if (conditions[2])
        {
            x=5; // [5, "13"] - located in two if-blocks, but not in the same as 'x=3'
        }
      }
      if (conditions[3])
      {
        x = 6; // [6, "4"] - located under one if on the main level
      }
   }
}
```
* Помечаем каждый уровень вложенности индексом (по возрастанию).
Если не находимся ни в одном if-блоке, индекс отсутствует.
  

* Таким образом, для
   каждого присвоения переменной **х** целочисленного значения есть строка
   с конкатенацией индексов уровней вложенности (см. пример).
  

* Проходя по коду, заполняем ассоциативный массив вида 
  
   (возможное значение переменной ; уровни вложенности, на которых находится присвоение)
  

* При выходе из метода method, проходим по ассоциативному массиву с конца
   * Последний добавленный элемент - последнее возможное значение х, сразу в результирующий список.
   * Сохраняем каждый уровень вложенности, с которого было взято значение переменной.
   * Если уровни вложенности каждого последующего элемента начинаются с того же уровня, с которого уже было взято значение переменной в результат - то это присвоение будет в последствии перезаписано и мы не берём его в результат. 
```     
Пример - идём с конца, сохранили 6, 5, 4. 
Обрабатываем 3 - уровни вложенности "12" начинаются с со строки "1", 
с которой уже было присвоение x=4. 
Соответственно, x=4 перезапишет x=3 и переменная не может принимать значение 3. 
Аналогично с x=2.
```

**Обработанные corner-cases:**
* Для того, чтобы иметь возможность обрабатывать случаи, когда переменной
присваивается одно и то же целочисленное значение, каждый раз при добавлении в ассоциативный массив
  к ключу (значению переменной) через underscore добавляется рандомный идентификатор, который отбрасывается 
  при прохождении через ассоциативный массив.
  

* Случаи, когда есть блок кода в скобках, но не в if-блоке:
```java
{
    x=1;
}
```



*Если в правой стороне выражения находится не число, а арифметическое выражение:
cначала подсчитываем значения выражения, потом сохраняем результат в массив.
```java
public class Main { 
   public static void method(boolean... conditions) { 
      int x;
      x= 1 + 55;     
   }
}
```


