Алгоритм (на примере исходного кода задания):

```java
public class Main { 
   public static void method(boolean... conditions) { 
      int x;
      x=1;          // [1, {0}] - not under any if statement
      if (conditions[0]) {
        x=2; // [2, {1}]  -  located in one if-block
        if (conditions[1]) {
            x=3; // [3, {1, 2}] - located in two opened if-blocks
        }
        x=4; // [4, {1}] - on the same level with 'x=2'
        if (conditions[2])
        {
            x=5; // [5, {1, 3}] - located in two if-blocks, but not in the same as 'x=3'
        }
      }
      if (conditions[3])
      {
        x = 6; // [6, {4}] - located under one if on the main level
      }
   }
}
```
* Помечаем каждый уровень вложенности индексом (по возрастанию).
Если не находимся ни в одном if-блоке, индекс отсутствует.
  

* Таким образом, для
   каждого присвоения переменной **х** целочисленного значения есть List со списком индексов уровней вложенности (см. пример).
  

* Проходя по коду, заполняем ассоциативный массив вида 
  
   (возможное значение переменной ; уровни вложенности, на которых находится присвоение)
  

* При выходе из метода method, проходим по ассоциативному массиву с конца
   * Последний добавленный элемент - последнее возможное значение х, сразу в результирующий список.
   * Сохраняем каждый уровень вложенности, с которого было взято значение переменной.
   * Если список уровней вложенности каждого последующего элемента целиком содержат в себе хотя бы один из списков уровней, которого уже было взято значение переменной в результат - то это присвоение будет в последствии перезаписано и мы не берём его в результат. 
```     
Пример - идём с конца, сохранили 6, 5, 4. 
Обрабатываем 3 - уровни вложенности {1, 2} содержат уровень {1}, 
с которого уже было присвоение x=4. 
Соответственно, x=4 перезапишет x=3 и переменная не может принимать значение 3. 
Аналогично с x=2.
```

**Обработанные corner-cases:**
* Для того, чтобы иметь возможность обрабатывать случаи, когда переменной
присваивается одно и то же целочисленное значение, каждый раз при добавлении в ассоциативный массив
  к ключу (значению переменной) через underscore порядковый номер, который отбрасывается 
  при прохождении через ассоциативный массив.
  

* Случаи, когда есть блок кода в скобках, но не в if-блоке:
```java
{
    x=1;
}
```



*Если в правой стороне выражения находится не число, а арифметическое выражение:
cначала подсчитываем значения выражения, потом сохраняем результат в массив.
```java
public class Main { 
   public static void method(boolean... conditions) { 
      int x;
      x= 1 + 55;     
   }
}
```

*Уровни вложенности могут иметь глубину больше 9 и выражаться двузначным числом (или более), поскольку теперь вместо строки используется целочисленный ImmutableList.
